% !TEX program = xelatex
\documentclass[a4paper,12pt, oneside]{article}
\usepackage[utf8]{inputenc}

\usepackage{graphicx} % To include images
\usepackage{xcolor} % To have more colors and be able to define new one
\usepackage{afterpage} % For the page background color
\usepackage{listings} % To include code snippets
\usepackage{indentfirst} % To indent the first paragraph
\usepackage{url} % For url...
\usepackage[all]{nowidow} % To prevent widow/orphan lines
\usepackage[margin=2.5cm]{geometry} % To change the margin
\usepackage[justification=justified,singlelinecheck=false]{caption} % To left align even the single line captions
\usepackage{multicol} % Enable multi columns environment
\usepackage{subcaption} % To have two figures next to each other
\usepackage{fontspec} % For custom fonts
\usepackage{lipsum} % Lorem ipsum generator
\usepackage{layouts} %to get the text width in cm
\usepackage{rotating} %to have some figures sideways.
\usepackage{placeins} % To force floats to be placed before the beginning of next section
\usepackage{parskip} % To add space between paragraphs

\usepackage{tikz}
\usepackage{pgf-umlsd}
\usepgflibrary{arrows}
\usetikzlibrary{positioning,fit,calc}

\setmainfont{Graublau Sans}
\setlength{\parindent}{1.5em}

\definecolor{gray}{rgb}{0.4,0.4,0.4}
\definecolor{darkblue}{rgb}{0.0,0.0,0.6}
\definecolor{cyan}{rgb}{0.0,0.6,0.6}
\definecolor{rocketorange}{rgb}{1,.4,0}

\lstset{
    basicstyle=\footnotesize\ttfamily,
    breaklines=true,
    columns=fullflexible,
    showstringspaces=false,
    commentstyle=\color{gray}\upshape,
    frame=l,
    captionpos=b,
    % Line numbers
    xleftmargin={0.75cm},
    numbers=left,
    stepnumber=1,
    firstnumber=1,
    numberfirstline=true
}

\lstdefinelanguage{XML}{
  morestring=[b]",
  morestring=[s]{>}{<},
  morecomment=[s]{<?}{?>},
  stringstyle=\color{black},
  identifierstyle=\color{darkblue},
  keywordstyle=\color{cyan},
  morekeywords={xmlns,version,type,title} % list your attributes here
}

\lstdefinelanguage{JavaScript}{
  morekeywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  morecomment=[s]{/*}{*/},
  morecomment=[l]//,
  morestring=[b]",
  morestring=[b]'
}

\lstdefinelanguage{HTML5}{
        language=html,
        sensitive=true,
        alsoletter={<>=-},
        otherkeywords={
        % HTML tags
        <html>, <head>, <title>, </title>, <meta, />, </head>, <body>,
        <canvas, \/canvas>, <script>, </script>, </body>, </html>, <!, html>, <style>, </style>, ><
        },
        ndkeywords={
        % General
        =,
        % HTML attributes
        charset=, id=, width=, height=,
        % CSS properties
        border:, transform:, -moz-transform:, transition-duration:, transition-property:, transition-timing-function:
        },
        morecomment=[s]{<!--}{-->},
        tag=[s]
}


% Customized commands
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

%Acknowledgements environment
\newenvironment{acknowledgments}
  {\renewcommand{\abstractname}{Acknowledgments}
   \begin{abstract}}
  {\end{abstract}}

\begin{document}
\pagenumbering{roman}

\input{./title.tex}

\vspace*{5cm}
\begin{acknowledgments}
    \lipsum[1] %TODO
\end{acknowledgments}
\newpage

\vspace*{5cm}
\begin{abstract}
    \lipsum[1] %TODO
\end{abstract}
\newpage

\tableofcontents
\newpage

\setcounter{page}{1}
\pagenumbering{arabic}

% Text width in cm: \printinunitsof{cm}\prntlen{\textwidth}

\section{Introduction}
Humans have ideas. Not a lot of those ideas end up being applied, no matter if they are good or bad.
Sometimes they just stay in the head of the person who had one and are not developed further because the person thinks it is not a good idea.
She might be right but she can't really know as long as she has not shared her idea.
And of course it happens that people do share their ideas.
That is something good to do because it can bring a lot of valuable input that we do not necessarily think about by ourselves.
This makes the idea evolve; it might go in one direction or another, change shape, or even generate new different ideas.
This can also be seen as what is called \emph{brainstorming}. This process is in general quite messy.
A lot of information is generated and not structured, which makes it difficult to highlight the most important items.
For brainstorming, teams sometimes use a ticketing system that they already use for other projects related tasks.
Tickets are great for development, but not good for creative brainstorming.

Therefore, what we want to achieve is to design and develop a platform that significantly improves collaboration around ideas within a team or a small to medium-sized company by getting considerably close to the cognitive working reality of a team.
We want to have a more human experience.
This will enable the users to have an effective way to bubble up the good ideas among all the information, and also to drive the sharing of new ideas.
All this should be highly intuitive and straightforward to use, by being particularly careful about the overall user experience of the platform.

\subsection{Flok}
Flok is the name of the platform we want to build.
This name comes from the term \emph{flock}, representing a large number of entities – people – moving together.
It fits well as we really want to focus on the collaboration among a group of people and how, together, they make ideas evolve, while respecting human behavior.

\subsection{Hypothesis}
\label{hypothesis}
It can be proven that a truly real-time approach to create, read and update information within on-site or remote, (inter-)disciplinary teams significantly improves their shared know-how and overall collaborative spirit thus leading to a verifiable increase of their creative potential.

\subsection{User-centered design}
The approach taken to create the platform is based on the \emph{user-centered design} concept.
The goal is to focus first on the user need and to start by designing the user interaction with the product to then define what the content is going to be and which technologies are going to be used.
The reason why we took this approach is because we really want the product to be intuitive for the end-users, that it matches their expectations regarding what they need, what they can do with the platform, rather than making them adapt their behavior.

To this end, different processes were used, such as \emph{User Story Mapping} to define the user needs, \emph{Wireframing} and \emph{Prototyping} to quickly test if the design of a functionality matches those user needs, and \emph{User testing} to have feedback from real users in order to adapt the platform to their expectations.
Moreover, we are not going through these different processes sequentially, but rather iteratively.
Each of these steps enable us to discover new issues, new opportunities and we have then to reflect those in every step.

% TODO What about integrating the "Product Design Process" of Nothing Interactive?
% Answer: Not necessarily. It is quite complex to explain, what is already in this section might be enough

\section{Personas}
In order to embrace the user-centered design concept, we have to put ourselves in the shoes of the users we expect to use the platform. To do this, \emph{personas} were created.
They are behavioural patterns build up from the ground who represent the different type of users that we might have.
We made three of them for the project.
All three work in the same startup. \emph{Andrew McAllister} is the CEO, \emph{Melanie Carter} a developer, and \emph{Sergei Fleming} an interaction designer.
These personas were not defined in much more details, as part of the research was to determine more clearly for which purpose Flok is going to be used.

\section{User Story Mapping}
\emph{User Story Mapping} (USM) is a technique which help teams developing software to stay focused on users and their needs \cite{patton2014user}.
It is based on user stories and story maps. \emph{User stories} are descriptions of how users are interacting with the whole product and not only with one of its feature. \emph{Story maps} are a two-dimensional visual representation of stories with \emph{cards} as atomic parts.
In general, the top row of cards represents the backbone of the story (from left to right), and the cards below give more details.
In addition to the focus it gives on the users, USM enables the discussion within the team who builds it to create a shared understanding of the product.
User story maps can be done with software tools which make it easier to edit and share. However, team collaboration is enhanced when people are facing a physical user story map made of sticky notes, which is what has been done for this project.

The user story map constantly evolves throughout the development of the project.
In figure \ref{fig.flokUsmEvolution} you have an overview of how it evolved for Flok.
Figure \ref{fig.flokUsmCurrent} shows you its state at the time of handing in this report.

The green sticky notes represent actions by users and the blue ones indicate which user are doing the actions.
In the latest versions of the user story map, we can notice that the orange sticky notes entitle \emph{slices}, of the story.
As said, the first row is the backbone.
Below we have three slices R1, R2 and R3, \emph{R} meaning \emph{release}.
It helps to define clearly which part of the story are the most important and therefore need to be possible to do for the user in the earliest versions of Flok. For the Master project, we went implemented the front-end up to R2 and left in R3 parts of the stories we didn't deem necessary to have in an early version of Flok.

Building this user story map was a bit more tricky than it can be for most others.
Indeed, as Flok interest resides in the real-time interactions between its users, the story has to jump often from a user to another.
This makes it also more difficult to follow when reading the story map.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=\textwidth]{images/flokUsmEvolution.png}
    \caption{Evolution of the user story map for Flok}
    \label{fig.flokUsmEvolution}
\end{figure}

% TODO Still subject to change until I hand in the report. Change the story description accordingly
\begin{figure}[!htb]
    \centering
    \includegraphics[width=\textwidth]{images/flokUsmCurrent.jpg}
    \caption{Current state of the user story map for Flok}
    \label{fig.flokUsmCurrent}
\end{figure}

\FloatBarrier
\subsubsection*{Story description}
The story simply start with Andrew having a rough idea that he wants to share in order to discuss about it and develop it.
He then adds the idea on Flok and describe it with text, but images as well.
From here, other users can take part to the idea. For instance, Melanie is looking for interesting ideas in the \emph{discovery} section of the app and she get inspired by the one from Andrew.
From here, she has several possibilities.
She can simply bookmark the idea in order to have it saved and hence, easily come back to it later.
She can also follow the idea in order to get informed of the activity occurring within it.
Then, as she is interested, she goes through a page which recaps the discussion around the idea.
This helps her to quickly have a good overview.
If she wants to actively take part to the idea, she can go to the discussion section and read the last comments before interacting.
As it happens, she agrees with Andrew's comment and show it by \emph{liking} it and replying directly to it.
Moreover she wants to find that comment later so she bookmarks it.
Then she gives her input by writing comments and sharing documents and images.
However, Andrew disagrees with the input from Melanie and he says it by replying to the corresponding comment.

Among the comments and other inputs of team mates taking part to Andrew's idea, he gets interested by the views of one specific person.
He looks at this person profile and more precisely in which other ideas she is active and that might interest him.

Back to Andrew's idea, after a while, Sergei joins the idea that he found through the \emph{discovery} section of the app.
He found the idea interesting and noticed that among the followers there were team mates he usually like their thinking.
He catches up the discussion through the recap and among the highlighted items one image appealed him.
He brings up the image in its context to see in more details what it is about.
This makes him think about another idea so instead of replying at this point of the discussion, he rather decides to fork from the image to create a new idea in Flok.

Initially new ideas are classified under the \emph{Incubating} label.
This is not the case anymore for Andrew's idea which has evolved and became more mature and precise.
Hence he decides to update the classification to \emph{Need to decide} where the discussion should be more about what are going to be the next step to implement the idea.
Moreover, the original name and description of the idea do not suit its content anymore.
Therefore Andrew updates them accordingly.

After a while, the idea reached the \emph{Open for execution} classification where it got successfully implemented.
At this point the idea can be archived, which is what Andrew does.

% TODO link the story map to the hypothesis.

\section{Information architecture}
To accompany and solidify the project it is important to have a good information architecture.
This helps to have a well defined vocabulary for the different elements making the product, and how they interact with each other.
In our case, we made an \emph{entity-relationship diagram} that you can see in figure \ref{fig.erDiagram}.
In the rectangle are the different entities in Flok.
The ovals their attributes and the diamonds are actions representing the relation between entities.
We have to read the relations from top to bottom (e.g. \emph{Persons are actor of Activity items} or \emph{Ideas contain Messages}).
The thickness of the lines and the fact they are an arrow or not also has a specific meaning, described in the bottom right of the figure.
For instance, a person can post none or more messages, but a specific message is posted by exactly one person.
Also, a message must be either an image, a file, a system information or a comment, and any of these four entities has to be a message.

\begin{sidewaysfigure}[!htb]
    \centering
    \includegraphics[width=\textwidth]{images/erDiagram.pdf}
    \caption{The entity-relationship diagram of Flok, representing its information architecture}
    \label{fig.erDiagram}
\end{sidewaysfigure}

\clearpage

\section{Wireframing}
Once we had a first version of the user story map, the next step was to build wireframes of the user interface.
Wireframes allow to quickly have a very rough view of the components layout and how they fit in the available space.
They enable us to see changes that need to be brought even before we start designing or implementing, and hence save us some precious time.

For instance, initially ideas were called \emph{topics} and when I designed the first wireframes of recap page for a topic, it was a kind of tag cloud with all the ideas discussed in a topic – The most discussed ones being more prominent (see figure \ref{fig.originalRecapWireframes}).
This made us realize two things.
First, there was a lack of shared understanding regarding the scope of the discussions we expect to be held in one topic and therefore also regarding the content of the recap page.
Secondly, the name \emph{topic} was not a good name to describe this concept.
This is what made us change the name for \emph{idea}. It is also more human – Instead of creating a topic on Flok when you have an idea, you just add an idea on Flok when you have one.
This shows that we were able avoid having to change a single line of code to apply this change as it was detected before we start the first prototype.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=\textwidth]{images/originalRecapWireframes.png}
    \caption{Original wireframe design of the recap page. From left to right: the main recap page, the recap page of one idea in the topic, the dialog asking if we want to see an item in its context, an item highlighted in its context.}
    \label{fig.originalRecapWireframes}
\end{figure}

You can notice in the wireframes of figure \ref{fig.originalRecapWireframes} that we choose to represent the app in a mobile screen.
This decision has been made because having less space forces us to think about what is the most important to show to the user.
It is then easier to design a desktop version from the mobile version than the other way around.
The \emph{Mobile First} development is also getting more important as more people are accessing the web from their mobile device before doing so from a desktop computer.

A few other design decisions were taken during wireframing.
For instance, it was initially possible to unlike a message in a discussion.
This has been removed to only keep the like button.
Indeed, it is not necessary to explicitly express a disagreement with this action which does not bring any constructive feedback and we also want to foster positivity.
A disagreement can still be express with a comment which should be more constructive.

This is also while designing the wireframes that we asked ourselves the question regarding the order the messages in a discussion.
Some researches \cite{mabande2010designing} concluded that having the oldest ones at the top and the more recent ones at the bottom was leading to more engagement from the participant of a discussion.
Following this order is also more human as it follows the natural reading order.
Moreover, as the input field to add messages is at the bottom, having the new messages appearing right above it is also expected.

% TODO link the wireframes to the hypothesis

\section{Prototyping}
The step following wireframing is prototyping.
In this case, the initial goal was to make it mostly visual in order to have a good idea of the look and feel, but also of the possible interactions from the users.
The content would consist of static mock data.
To avoid having to create a full visual design, we decided to use the component library \emph{Material Design Lite}\footnote{\url{http://getmdl.io}}, which is an implementation of \emph{Material Design}\footnote{\url{http://google.com/design/spec}}.
This lightweight library, with the use of some HTML, CSS and simple Javascript, enabled us to quickly have a prototype with a solid visual design (see figure \ref{fig.firstPrototypeScreenshots}).

\begin{figure}[!htb]
    \centering
    \includegraphics[width=\textwidth]{images/firstPrototypeScreenshots.png}
    \caption{Screenshots of Flok first prototype using \emph{Material Design Lite}}
    \label{fig.firstPrototypeScreenshots}
\end{figure}

Improvements and features have been progressively added to the prototype.
With, all the necessary code to keep it interactive.
However, as it was initially planned to be light, having a bigger code base was not adapted with the prototype structure making it quite messy and therefore more difficult to add new components.
The visual result being good, it seemed to be the right moment to start working on the functional front-end of the platform, based on the prototype.

\section{Front-end}
\subsection{Architecture}
\label{sec.architecture}
We wanted the platform to be fully usable from any device.
The easiest way to implement that is to have a responsive web application.
Hence, Javascript and the \emph{MEAN stack} seemed quite appropriate.
These are also technologies in which \emph{Nothing Interactive} has good experience with.
This means that regarding the front-end we went for a single page application made with \emph{AngularJS}.

As we were satisfied with the result of using Material Design for the prototype, we wanted to continue following those guidelines.
Obviously, Material Design Lite was not enough, therefore we had to use another implementation.
Looking at the different alternatives and knowing that we were going to use AngularJS, the decision to use \emph{Angular Material}\footnote{\url{https://material.angularjs.org}} was straightforward.

There are different ways to build an AngularJS application.
Therefore it was important that we clearly define how we were going to structure it.
\emph{Nothing Interactive} has some internal guidelines, but with the arrival of \emph{Angular 2}, it seemed to be a good time to re-think those guidelines in order to write code that would enable an easy transition to this disruptive new version of the framework.
Hence, we made some adaptations based an Angular Style Guide written by John Papa\footnote{\url{https://github.com/johnpapa/angular-styleguide}}, which is endorsed by the Angular team.

Unfortunately, our great focus on building the front-end and having the best user experience possible did not gave us time to build a functional back-end for the app.
At some point we had to take the decision between either building the back-end, or doing the user testing.
The latter seemed more important as it would (in)validate our assumptions regarding the interaction of the user with the platform.
We also estimated that it would bring us valuable feedback to improve the front-end.

Not having a back-end implies some restrictions.
First, it means that once the AngularJS app is loaded in the browser, everything is happening in the browser only and there is no communication with the server, except to get static files such as images.
Therefore, interaction between two users is not possible.
Then, no back-end also means no database and no saved data.
Fortunately, as the front-end is a single page application, as long as the page is not fully refreshed, all the data created by the user while using Flok is saved in memory, including uploaded files.
This is shown in figure \ref{fig.dealingWithoutBackend}, where directives, controllers and service are concepts coming from AngularJS.
Therefore the user can still use and evolve in the app.

\begin{figure}[!htb]
    \centering
    \begin{tikzpicture}
        \node (frontend) [minimum height=4cm, minimum width=9.5cm, draw=black, anchor=north west] at (0,0) {};
        \node [below right, inner sep=.3cm] at (frontend.north west) {Front-end};

        \node (directive) [minimum height=2.5cm, minimum width=4cm, draw=black, anchor=north west] at (.5,-1) {};
        \node [below right, inner sep=.3cm] at (directive.north west) {Directive};

        \node (service) [minimum height=2.5cm, minimum width=4cm, draw=black, anchor=north west] at (5,-1) {};
        \node [below right, inner sep=.3cm] at (service.north west) {Service};

        \node (controller) [draw=black, anchor=north west] at (1, -2) {Controller};
        \node (memory) [draw=black, anchor=north west] at (5.5, -2) {Memory};

        \node (backend) [draw=black!30, color=black!30, minimum height=4cm, minimum width=4cm, anchor=north west] at (12,0) {Back-end};

        \draw[->, >=latex, thick, transform canvas={yshift=2mm}] (controller) -- (service);
        \draw[<-, >=latex, thick, transform canvas={yshift=-2mm}] (controller) -- (service);
        \draw[->, >=latex, thick, transform canvas={yshift=2mm}, color=black!30] (service) -- (service-|backend.west);
        \draw[<-, >=latex, thick, transform canvas={yshift=-2mm}, color=black!30] (service) -- (service-|backend.west);
    \end{tikzpicture}
    \caption{Schema illustrating data flow for Flok. In the front-end, the controllers of directives ask for data to services. Those services should ask the back-end for the information stored in the database. But as there's no back-end, services get the information from their own memory.}
    \label{fig.dealingWithoutBackend}
\end{figure}

We were not trying to build a fully working application without backend.
Therefore we still kept in mind an architecture that would communicate with a back-end by simulating calls to it, even though we just get the data from memory.

\subsection{Implementation and design decisions}
We are not going to describe the implementation of every component as some of them are quite straightforward.
We are rather going to explain the components where some reflexion had to be made or decisions had to be taken.

\subsubsection{Ideas}
Ideas are the main components of Flok.
They are created by users and they have three different views.
The main view (figure \ref{fig.idea.main}) gives the general information about the idea: author, creation date, description, classification (section \ref{sec.ideasClassification}), followers and relations with other ideas.
From here you can also trigger actions on the idea such as following, bookmarking, archiving and forking (section \ref{sec.fork}).
The available actions depend of the status of the user (creator, follower) toward the idea.
Then there is the discussion view (figure \ref{fig.idea.discussion}) where all the messages (section \ref{sec.messages}) related to the idea can be found.
This is also where messages can be added to the discussion.
Finally there is the recap view (figure \ref{fig.idea.recap} and section \ref{sec.recap}) which highlight the most important messages of the discussion.

\begin{figure}[!htb]
    \begin{subfigure}[t]{.32\textwidth}
        \includegraphics[width=\textwidth]{images/idea.png}
        \caption{Main view}
        \label{fig.idea.main}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{.32\textwidth}
        \includegraphics[width=\textwidth]{images/ideaDiscussion.png}
        \caption{Discussion view}
        \label{fig.idea.discussion}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{.32\textwidth}
        \includegraphics[width=\textwidth]{images/ideaRecap.png}
        \caption{Recap view}
        \label{fig.idea.recap}
    \end{subfigure}
    \caption{Screenshots of Flok front-end featuring the different views of an idea}
    \label{fig.idea}
\end{figure}

\FloatBarrier
\subsubsection{Ideas classification}
\label{sec.ideasClassification}
Here there is actually not much to say regarding the implementation itself.
We introduced these classification in order to easily visualize the state of an idea.
Initially, to update the classification, it has either to be promoted or demoted, respectively to the next or previous classification.
To do so, one of the idea follower had to start a poll asking all the followers to vote for or against and change of classification (see figure \ref{fig.promotionPoll}).
The goal here was to reflect a common decision.

\begin{figure}[!htb]
    \begin{subfigure}[t]{.32\textwidth}
        \includegraphics[width=\textwidth]{images/promotionPoll_dialog.png}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{.32\textwidth}
        \includegraphics[width=\textwidth]{images/promotionPoll_question.png}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{.32\textwidth}
        \includegraphics[width=\textwidth]{images/promotionPoll_approved.png}
    \end{subfigure}
    \caption{Screenshots of Flok prototype featuring the promotion poll}
    \label{fig.promotionPoll}
\end{figure}

Then we realized the process can actually get complicated.
What happens if not all followers vote?
Should we wait?
Should we define a time limit to vote? Should such a time limit be define by the poll initiator?
What happens if there is a draw?
We thought about how to reply to these questions and we could have implemented solutions, but in the end this might be a hassle for the user to make that change of state.
Therefore we went for a drastic simplification.
No more poll, no more promotion or demotion.
We simply let any follower update the classification to any available (see figure \ref{fig.classificationSelect}).
The change is instantly applied.
Now there might be disagreement within the followers, but they are all in the same team and they can discuss that.
And as it is so simple to change the classification, they can easily reversed their decisions.
Having simplified this action also enabled us to implement an interactive way for the user to update the classification from desktop, by drag and dropping ideas in \emph{Kanban}\footnote{\url{https://en.wikipedia.org/wiki/Kanban}} columns (see figure \ref{fig.classificationDragAndDrop}).
You will also notice that these columns are color-coded in order to make it even more clearer for the users to understand what can be executed.

\begin{figure}[!htb]
    \null\hfill
    \begin{subfigure}{.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/classificationSelect_selected.png}
    \end{subfigure}
    \hfill
    \begin{subfigure}{.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/classificationSelect_selecting.png}
    \end{subfigure}
    \hfill\null
    \caption{Screenshots of Flok front-end featuring the simple classification update of an idea}
    \label{fig.classificationSelect}
\end{figure}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=\textwidth]{images/classificationDragAndDrop.png}
    \caption{Screenshots of Flok front-end featuring the drag and drop of an idea from a classification to another}
    \label{fig.classificationDragAndDrop}
\end{figure}

\FloatBarrier
\subsubsection{Messages}
\label{sec.messages}
Messages are one of the central components of Flok.
They have one author, they are part of one idea and they are either a comment, an image, a document, a system information or a deleted message.
When adding a message to a discussion, it can be the reply to another message and thus help to establish relations among messages (see figure \ref{fig.messageView}).
For more details on the properties of each of these type and on the relations of messages with other entities of Flok, we send you back to the entity-relationship diagram in figure \ref{fig.erDiagram}.
We'd still like to mention the support of hashtags in comments.
When clicking on one, we are brought to the hashtag view, which list all occurrences of the hashtag in all ideas (see figure \ref{fig.hashtagView}).

Below each message, a list of actions is offered to the users.
They can like the message, bookmark it, reply to it or fork it.
Liking a message helps defining which messages have more value than others.
This will notably be used for the recap view, which we are talking about in section \ref{sec.recap}.
Bookmarking a message adds it in the bookmark list of the users who can access it from their profile.
It is a way to save messages they want to easily access later.
Message forking is covered in section \ref{sec.fork}.
And if we are the author of a message, we have an additional \emph{three dots} button toggling a menu to either edit or delete a message.

When we introduced the possibility to delete a message, it was really completely deleted.
However, it also broke relations between messages and ideas, which are made through replies and forks.
Therefore we decided to add the \emph{deleted} message type, where the content of the message is deleted, but the object itself not.
Like this the relations are kept.

\begin{figure}[!htb]
    \null\hfill
    \begin{subfigure}[t]{.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/messageView.png}
        \caption{The message is highlighted, above we have the message it is replying to and below we have the replies.}
        \label{fig.messageView}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/hashtagView.png}
        \caption{The hashtag view list all the occurrences of a hashtag throughout all the ideas.}
        \label{fig.hashtagView}
    \end{subfigure}
    \hfill\null
    \caption{Screenshots of Flok front-end featuring messages and hashtags.}
\end{figure}

\subsubsection{Fork}
\label{sec.fork}
If we try to look at how humans think, they initially have an idea that they brainstorm by themselves or with other people.
It then generates new ideas based on the brainstorm and it can go on until an idea really gets developed and executed.
We tried to represent that in Flok with the \emph{fork} feature.
Basically, you can create an idea by forking another idea or a message.
The word comes from the software development world, when a copy of source code is made to start developing on it independently.
However it works a bit differently in Flok.
The main goal is to create the relation between the initial idea or message to the newly created idea.
Nothing is automatically taken from the source which means that the new idea form is blank and the user still has to describe her idea.
Once the idea is created, the discussion can begin, as any new idea.
The difference lies in the relation created, which goals is to represent the human way of thinking.
We wanted to make these relations more visible and therefore implemented visualizations showing forks relations (see figure \ref{fig.forks}).
Clicking on the fork symbol in the Ideas Overview will bring to the fork navigation.
We can also get there by clicking on the number of forks from the view of an idea.

\begin{figure}[!htb]
    \centering
    \begin{subfigure}[t]{.32\textwidth}
        \includegraphics[width=\textwidth]{images/forks_ideasOverview.png}
        \caption{The ideas that are forks or that have been forked are noticeable by a specific symbol symbol on the right.}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{.32\textwidth}
        \includegraphics[width=\textwidth]{images/forks_idea.png}
        \caption{In the idea view, it is indicated from which idea an idea has been forked from, as well as how many forks it is the source of.}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{.32\textwidth}
        \includegraphics[width=\textwidth]{images/forks_navigation.png}
        \caption{The forks navigation shows up to two parents or children fork level.}
    \end{subfigure}
    \caption{Screenshots of Flok front-end featuring forks visualization.}
    \label{fig.forks}
\end{figure}

\subsubsection{Recap}
\label{sec.recap}
We mentioned earlier the fact that brainstorming is a process which can easily get messy, which is normal and natural.
As we try to be close to the human way of doing, discussions in Flok give the same liberty, which can bring the same messiness.
However, this liberty let the user express her thoughts and that's why we want to keep it.
Nevertheless, we want to highlight the most important points of the discussion, bubble up the good ideas.
This is what the recap do.
You already saw how it looks like on mobile in figure \ref{fig.idea.recap}.
This same layout on a desktop would be quite inefficient, therefore we adapted the view to give a better experience when showing the recap on a large screen, as you can see in figure \ref{fig.recap.desktop}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=\textwidth]{images/recapDesktop.png}
    \caption{Screenshot of Flok front-end featuring the recap view from a large screen}
    \label{fig.recap.desktop}
\end{figure}

To select the messages and show them in a specific order, it runs an algorithm which returns the most relevant messages and order them by importance.
Such an algorithm should obviously run in the back-end of the system.
But as explained in section \ref{sec.architecture}, we unfortunately don't have any back-end.
That's why we implemented the recap algorithm in the front-end.

Initially we wanted to take into consideration the text content of the messages and use some topic modeling to discover the different main topics discussed.
The \emph{Latent Dirichlet Allocation} \cite{blei2003latent} model seemed to be a good one to use for the algorithm.
Nonetheless, as we are running the algorithm in the front-end, we went for something simpler.
We give a weight to each message of the idea's discussion based on the following properties, to which we give more or less impact.

\begin{multicols}{2}
    \begin{itemize}
        \item number of replies $r$
        \item number of bookmarks $b$
        \item number of likes $l$
        \item number of forks $f$
        \item is an image $i = 1 | 0$
        \item is a document $d = 1 | 0$
        \item text length (in words) $t$
    \end{itemize}
\end{multicols}

The weight of messages $w_m$ is then computed as follows.

\begin{equation}
    \label{eq.messageWeightInRecap}
    w_m = 4r + 3b + 2l + f + i + d + \frac{t}{250}
\end{equation}

The minimum weight for a message to be included in the recap is 1.
This means that all images or documents are by default included.
We are doing so in order to very rapidly have some content in the recap when an idea is created.
As the messages in the recap are ordered by weight, if images or documents don't get more weight, they will simply stay at the bottom.

You will notice in equation \ref{eq.messageWeightInRecap} that some of the message properties are weighted with different factors.
Replies have the most importance with a factor 4.
Indeed, replying to a message means that this message generated engagement and new content in the idea.
Therefore it is certainly good to have it in the recap.
If a user bookmark a message, it means he want to have it saved for himself.
This shows a strong interest for the message, thus this being the second most important property with a factor 3.
When users bookmark a message, it affects their bookmark list and they will therefore be careful regarding what they bookmark.
The likes however, are only affecting the message which receives them and not the users who give them.
Hence the reason we give them less importance than bookmarks.
They still have a factor 2 as they are used to show support or agreement.
Forking a message means creating a new idea.
Therefore, we could say that a message that has been forked is of great importance.
It certainly is for the newly created idea, but for the idea containing this message, it does not necessarily have that much importance.
If it does, then it would get replies, bookmarks or likes that are going to make it appear in the recap.
This is why forks only have a factor 1 in the computation of a message weight.
Then, we are adding 1 to the message weight if it is a document or an image.
As these types of messages are more visual or bring more content than a simple comment, we decided they deserve from the beginning to have the minimum weight to appear in the recap.
Finally, the text length of a comment also influence the weight of the message.
If it has enough content, i.e. 250 words, then it will appear in the recap.
And the more it has, the bigger its weight will be, the higher it will be in the recap.

In addition to messages, the recap view also features hashtags.
To show them among the messages, they also have a weight $w_h$ based on the number of mentions $m$.

\begin{equation}
    \label{eq.hashtagWeightInRecap}
    w_h = 0.5m
\end{equation}

Hence, a hashtag appears in the recap if it has at least two mentions in the discussion.

Of course, for this simple algorithm, the given factors are based on assumptions and only testing in a real-life situation would show us if the result is matching users expectations.

\subsubsection{Activity}
The activity section of Flok shows to the user the recent events occurring in ideas she follows and not triggered by herself (see figure \ref{fig.activity}).
This allow her to have a quick overview of everything that happened in the ideas she is interested in.
If she wants to see her own activity, it is visible within her profile.
The actions that are logged in the activity are the following:
\begin{multicols}{2}
    \begin{itemize}
        \item creating an idea
        \item forking an idea
        \item following an idea
        \item moving an idea from a classification to another
        \item renaming an idea
        \item adding a message (comment, image or file)
        \item liking a message
    \end{itemize}
\end{multicols}

This activity feature is something we often see in social applications and therefore, it has been implemented in various ways.
In prevision of any future integration with other external platforms, we decided to follow as closely as possible the \emph{W3C Activity Streams 2.0} standard \cite{snell2015AS2}.
Currently, it is still a working draft, and hence subject to change.
The main efforts have been focused in respecting the properties of an \emph{Activity} object and in using the \emph{W3C Activity Vocabulary} \cite{snell2015AV} when applicable.

Activity can be logged from anywhere in the application by using the \texttt{log} method from \texttt{activityService}, an AngularJS factory.
All the activity is stored in this service and we can either get the global activity using the \texttt{getActivity} method, or get the activity specific to one person using the \texttt{getPersonActivity} method.

This part of Flok did not receive as much improvement as other parts.
Indeed, it is interesting to look at the activity in the platform to see what others are doing.
But as interaction between users is not possible yet without a back-end, it was difficult to see the activity grow and therefore notice if the way it has been implemented is adapted.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=.32\textwidth]{images/activity.png}
    \caption{Screenshot of Flok front-end featuring the activity of the platform}
    \label{fig.activity}
\end{figure}

\section{User testing}
In order to check the assumptions made during the user centered design process, we made three user testing sessions.
We used the service TestingTime\footnote{\url{http://testingtime.com}} to find test users.
The tests were made through Skype with the test users sharing their screen.
We spread the tests over one week, on Monday, Wednesday and Friday.
The time between two tests allowed us to make some adjustments to the front-end before the next step and directly see if it already improved the user experience.

When explaining the test and giving instructions, we did not give information about how the app works.
We wanted to see if people can understand the usage by themselves.
We asked the test users to describe us what they do and what they expect to happen when interacting with the app.
We also asked them to tell if they understand or not what is happening and if there is anything they like or dislike when using Flok.
Moreover, as the test session have been done with desktop computers, the app was tested with a desktop viewport.

The test sessions were divided in two parts.
The first part was about testing the app without any initial content.
The goal is to see how someone discover and learn to use the app.
As there cannot be two people communicating through Flok yet (see section \ref{sec.architecture}), the test users cannot have interaction with other users or see how the app could be used to collaborate.
That is were the second part of the test session come in.
There, the test users start using the app with some initial mock content.
They can see discussions between several people about one idea, which could help them understand other aspects of the app.

\subsection{Tests issues}
Doing user testing via Skype was a first for me, but also for the company.
Therefore there was a lot of unknown regarding how it is going to happen.
The first unexpected event was that the first test user did not have an up to date browser installed on her computer.
Older browser compatibility is something that has been put aside for now and therefore the layout of the app was not correct at several places.
As the test was limited in time, we did not asked the user to download a more recent browser and tried to test the app with the broken layout.
Fortunately, almost all the functionalities were working correctly.
We learned from that situation to ask in advance the test users to have an up to date browser ready for the coming test.

\subsection{First test session}
The first test user was a 34 years old woman.

\subsection{Second test session}
The second test user was a 42 years old man.

\subsection{Third test session}
The third test user was a 26 years old woman.

%TODO explain what we couldn't test with user, such as interaction with other users.

\section{Conclusion}

\clearpage
\bibliographystyle{ieeetr}
\bibliography{main}

\end{document}
